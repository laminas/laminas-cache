{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-cache Laminas\\Cache provides a general cache system for PHP. The Laminas\\Cache component is able to cache different patterns (class, object, output, etc) using different storage adapters (DB, File, Memcache, etc). File issues at https://github.com/laminas/laminas-cache/issues Documentation is at https://docs.laminas.dev/laminas-cache/ Benchmarks We provide scripts for benchmarking laminas-cache using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"Home"},{"location":"#laminas-cache","text":"Laminas\\Cache provides a general cache system for PHP. The Laminas\\Cache component is able to cache different patterns (class, object, output, etc) using different storage adapters (DB, File, Memcache, etc). File issues at https://github.com/laminas/laminas-cache/issues Documentation is at https://docs.laminas.dev/laminas-cache/","title":"laminas-cache"},{"location":"#benchmarks","text":"We provide scripts for benchmarking laminas-cache using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"Benchmarks"},{"location":"psr16/","text":"PSR-16 Available since version 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\StorageFactory; use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue(); if (! $cache->has('someKey')) { $cache->set('someKey', $value); } // Or use a default value: $value = $cache->get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache->set('someKey', $value, 30); // set TTL to 30s $cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], 3600); // set TTL to 1 hour $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], new DateInterval('P6H'); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification . Serialization PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: // Manual attachment after you have an instance: $cache->addPlugin(new Serializer()); // Via configuration: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => [ 'serializer', ], ]); Deleting Items and Exceptions PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"PSR-16"},{"location":"psr16/#psr-16","text":"Available since version 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\StorageFactory; use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue(); if (! $cache->has('someKey')) { $cache->set('someKey', $value); } // Or use a default value: $value = $cache->get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache->set('someKey', $value, 30); // set TTL to 30s $cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], 3600); // set TTL to 1 hour $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], new DateInterval('P6H'); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification .","title":"PSR-16"},{"location":"psr16/#serialization","text":"PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: // Manual attachment after you have an instance: $cache->addPlugin(new Serializer()); // Via configuration: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => [ 'serializer', ], ]);","title":"Serialization"},{"location":"psr16/#deleting-items-and-exceptions","text":"PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"Deleting Items and Exceptions"},{"location":"psr6/","text":"PSR-6 Available since version 2.8.0 Overview The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them. Quick Start To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\StorageFactory; use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool->getItem('foo'); // check whether item was found if (! $item->isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item->set($value); $pool->save($item); } // use the value of the item echo $item->get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found. Supported Adapters The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call. Quirks APC You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour. Logging Errors The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception->getFile(), $exception->getLine(), $exception->getCode(), $exception->getMessage() ); $logger->error($message); }; } $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', ], 'plugins' => [ 'exceptionhandler' => [ 'exception_callback' => $cacheLogger, 'throw_exceptions' => true, ], ], ]); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() . Supported Data Types As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"PSR-6"},{"location":"psr6/#psr-6","text":"Available since version 2.8.0","title":"PSR-6"},{"location":"psr6/#overview","text":"The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them.","title":"Overview"},{"location":"psr6/#quick-start","text":"To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\StorageFactory; use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool->getItem('foo'); // check whether item was found if (! $item->isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item->set($value); $pool->save($item); } // use the value of the item echo $item->get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found.","title":"Quick Start"},{"location":"psr6/#supported-adapters","text":"The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call.","title":"Supported Adapters"},{"location":"psr6/#logging-errors","text":"The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception->getFile(), $exception->getLine(), $exception->getCode(), $exception->getMessage() ); $logger->error($message); }; } $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', ], 'plugins' => [ 'exceptionhandler' => [ 'exception_callback' => $cacheLogger, 'throw_exceptions' => true, ], ], ]); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() .","title":"Logging Errors"},{"location":"psr6/#supported-data-types","text":"As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"Supported Data Types"},{"location":"pattern/callback-cache/","text":"CallbackCache The callback cache pattern caches the results of arbitrary PHP callables. Quick Start use Laminas\\Cache\\PatternFactory; use Laminas\\Cache\\Pattern\\PatternOptions; // Via the factory: $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc', 'cache_output' => true, ]); // Or the equivalent manual instantiation: $callbackCache = new \\Laminas\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new PatternOptions([ 'storage' => 'apc', 'cache_output' => true, ])); Configuration Options Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. cache_output boolean true Whether or not to cache callback output. Available Methods In addition to the methods defined in the PatternInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; use Laminas\\Stdlib\\ErrorHandler; class CallbackCache extends AbstractPattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); } Examples Instantiating the Callback Cache Pattern use Laminas\\Cache\\PatternFactory; $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc' ]);","title":"CallbackCache"},{"location":"pattern/callback-cache/#callbackcache","text":"The callback cache pattern caches the results of arbitrary PHP callables.","title":"CallbackCache"},{"location":"pattern/callback-cache/#quick-start","text":"use Laminas\\Cache\\PatternFactory; use Laminas\\Cache\\Pattern\\PatternOptions; // Via the factory: $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc', 'cache_output' => true, ]); // Or the equivalent manual instantiation: $callbackCache = new \\Laminas\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new PatternOptions([ 'storage' => 'apc', 'cache_output' => true, ]));","title":"Quick Start"},{"location":"pattern/callback-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. cache_output boolean true Whether or not to cache callback output.","title":"Configuration Options"},{"location":"pattern/callback-cache/#available-methods","text":"In addition to the methods defined in the PatternInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; use Laminas\\Stdlib\\ErrorHandler; class CallbackCache extends AbstractPattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"Available Methods"},{"location":"pattern/callback-cache/#examples","text":"","title":"Examples"},{"location":"pattern/capture-cache/","text":"CaptureCache The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources. Quick Start For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\PatternFactory; $capture = Laminas\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // Start capturing all output, excluding headers, and write to the public // directory: $capture->start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output Configuration Options Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int | bool 0600 ( false on Windows) Default permissions for generated output files. dir_permission int | bool 0700 ( false on Windows) Default permissions for generated output directories. umask int bool false Available Methods In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; use Laminas\\Stdlib\\ErrorHandler; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); } Examples Scaling Images in the Web Root Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php $captureCache = Laminas\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // TODO","title":"CaptureCache"},{"location":"pattern/capture-cache/#capturecache","text":"The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources.","title":"CaptureCache"},{"location":"pattern/capture-cache/#quick-start","text":"For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\PatternFactory; $capture = Laminas\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // Start capturing all output, excluding headers, and write to the public // directory: $capture->start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output","title":"Quick Start"},{"location":"pattern/capture-cache/#configuration-options","text":"Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int | bool 0600 ( false on Windows) Default permissions for generated output files. dir_permission int | bool 0700 ( false on Windows) Default permissions for generated output directories. umask int bool false","title":"Configuration Options"},{"location":"pattern/capture-cache/#available-methods","text":"In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; use Laminas\\Stdlib\\ErrorHandler; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"Available Methods"},{"location":"pattern/capture-cache/#examples","text":"","title":"Examples"},{"location":"pattern/class-cache/","text":"ClassCache The ClassCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead generates the callbacks for any public static method invoked on the class being cached, and caches static properties. Quick Start use Laminas\\Cache\\PatternFactory; $classCache = PatternFactory::factory('class', [ 'class' => 'MyClass', 'storage' => 'apc', ]); Configuration Options Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. class string none Name of the class for which to cache method output. cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. class_cache_methods array [] List of methods to cache (if cache_by_default is disabled). class_non_cache_methods array [] List of methods to omit from caching (if cache_by_default is enabled). Available Methods In addition to the methods defined in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache; use Laminas\\Cache\\Exception; class ClassCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Intercept method overloading; proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args) { return $this->call($method, $args); } /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: set a static property. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value) { $class = $this->getOptions()->getClass(); $class::$name = $value; } /** * Property overloading: get a static property. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name) { $class = $this->getOptions()->getClass(); return $class::$name; } /** * Property overloading: does the named static property exist? * * @param string $name * @return bool */ public function __isset($name) { $class = $this->getOptions()->getClass(); return isset($class::$name); } /** * Property overloading: unset a static property. * * @param string $name * @return void */ public function __unset($name) { $class = $this->getOptions()->getClass(); unset($class::$name); } } Examples Caching of Import Feeds $cachedFeedReader = Laminas\\Cache\\PatternFactory::factory('class', [ 'class' => 'Laminas\\Feed\\Reader\\Reader', 'storage' => 'apc', // The feed reader doesn't output anything, // so the output doesn't need to be caught and cached: 'cache_output' => false, ]); $feed = $cachedFeedReader->call(\"import\", array('http://www.planet-php.net/rdf/')); // OR $feed = $cachedFeedReader->import('http://www.planet-php.net/rdf/');","title":"ClassCache"},{"location":"pattern/class-cache/#classcache","text":"The ClassCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead generates the callbacks for any public static method invoked on the class being cached, and caches static properties.","title":"ClassCache"},{"location":"pattern/class-cache/#quick-start","text":"use Laminas\\Cache\\PatternFactory; $classCache = PatternFactory::factory('class', [ 'class' => 'MyClass', 'storage' => 'apc', ]);","title":"Quick Start"},{"location":"pattern/class-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. class string none Name of the class for which to cache method output. cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. class_cache_methods array [] List of methods to cache (if cache_by_default is disabled). class_non_cache_methods array [] List of methods to omit from caching (if cache_by_default is enabled).","title":"Configuration Options"},{"location":"pattern/class-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache; use Laminas\\Cache\\Exception; class ClassCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Intercept method overloading; proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args) { return $this->call($method, $args); } /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: set a static property. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value) { $class = $this->getOptions()->getClass(); $class::$name = $value; } /** * Property overloading: get a static property. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name) { $class = $this->getOptions()->getClass(); return $class::$name; } /** * Property overloading: does the named static property exist? * * @param string $name * @return bool */ public function __isset($name) { $class = $this->getOptions()->getClass(); return isset($class::$name); } /** * Property overloading: unset a static property. * * @param string $name * @return void */ public function __unset($name) { $class = $this->getOptions()->getClass(); unset($class::$name); } }","title":"Available Methods"},{"location":"pattern/class-cache/#examples","text":"","title":"Examples"},{"location":"pattern/intro/","text":"Introduction Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects. Quick Start Pattern objects can either be created from the provided Laminas\\Cache\\PatternFactory , or by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes. // Via the factory: $callbackCache = Laminas\\Cache\\PatternFactory::factory('callback', [ 'storage' => 'apc', ]); // Or the equivalent manual instantiation: $callbackCache = new Laminas\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new Laminas\\Cache\\Pattern\\PatternOptions([ 'storage' => 'apc', ])); Available Methods The following methods are implemented by Laminas\\Cache\\Pattern\\AbstractPattern . Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Set pattern options * * @param PatternOptions $options * @return PatternInterface */ public function setOptions(PatternOptions $options); /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); }","title":"Introduction"},{"location":"pattern/intro/#introduction","text":"Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects.","title":"Introduction"},{"location":"pattern/intro/#quick-start","text":"Pattern objects can either be created from the provided Laminas\\Cache\\PatternFactory , or by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes. // Via the factory: $callbackCache = Laminas\\Cache\\PatternFactory::factory('callback', [ 'storage' => 'apc', ]); // Or the equivalent manual instantiation: $callbackCache = new Laminas\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new Laminas\\Cache\\Pattern\\PatternOptions([ 'storage' => 'apc', ]));","title":"Quick Start"},{"location":"pattern/intro/#available-methods","text":"The following methods are implemented by Laminas\\Cache\\Pattern\\AbstractPattern . Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Set pattern options * * @param PatternOptions $options * @return PatternInterface */ public function setOptions(PatternOptions $options); /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); }","title":"Available Methods"},{"location":"pattern/object-cache/","text":"ObjectCache The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties. Quick Start use stdClass; use Laminas\\Cache\\PatternFactory; $object = new stdClass(); $objectCache = PatternFactory::factory('object', [ 'object' => $object, 'storage' => 'apc' ]); Configuration Options Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null | string Class name of object Hopefully unique! cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties boolean false Whether or not to cache properties exposed by method overloading. Available Methods In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); } Examples Caching a Filter $filter = new Laminas\\Filter\\RealPath(); $cachedFilter = Laminas\\Cache\\PatternFactory::factory('object', [ 'object' => $filter, 'object_key' => 'RealpathFilter', 'storage' => 'apc', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' => false, ]); $path = $cachedFilter->call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter->filter('/www/var/path/../../mypath');","title":"ObjectCache"},{"location":"pattern/object-cache/#objectcache","text":"The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties.","title":"ObjectCache"},{"location":"pattern/object-cache/#quick-start","text":"use stdClass; use Laminas\\Cache\\PatternFactory; $object = new stdClass(); $objectCache = PatternFactory::factory('object', [ 'object' => $object, 'storage' => 'apc' ]);","title":"Quick Start"},{"location":"pattern/object-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null | string Class name of object Hopefully unique! cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties boolean false Whether or not to cache properties exposed by method overloading.","title":"Configuration Options"},{"location":"pattern/object-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"Available Methods"},{"location":"pattern/object-cache/#examples","text":"","title":"Examples"},{"location":"pattern/output-cache/","text":"OutputCache The OutputCache pattern caches output between calls to start() and end() . Quick Start use Laminas\\Cache\\PatternFactory; $outputCache = PatternFactory::factory('output', [ 'storage' => 'apc' ]); Configuration Options Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. Available Methods In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractPattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); } Examples Caching simple View Scripts $outputCache = Laminas\\Cache\\PatternFactory::factory('output', [ 'storage' => 'apc', ]); $outputCache->start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache->end();","title":"OutputCache"},{"location":"pattern/output-cache/#outputcache","text":"The OutputCache pattern caches output between calls to start() and end() .","title":"OutputCache"},{"location":"pattern/output-cache/#quick-start","text":"use Laminas\\Cache\\PatternFactory; $outputCache = PatternFactory::factory('output', [ 'storage' => 'apc' ]);","title":"Quick Start"},{"location":"pattern/output-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Laminas\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data.","title":"Configuration Options"},{"location":"pattern/output-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractPattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"Available Methods"},{"location":"pattern/output-cache/#examples","text":"","title":"Examples"},{"location":"storage/adapter/","text":"Adapters Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass either the options instance or associative array to the Laminas\\Cache\\StorageFactory::factory method. Many Methods throw Exceptions Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions. Quick Start Caching adapters can either be created from the provided Laminas\\Cache\\StorageFactory , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\StorageFactory comes with a factory() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\StorageFactory; // Via factory: $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => ['ttl' => 3600], ], 'plugins' => [ 'exception_handler' => ['throw_exceptions' => false], ], ]); // Alternately, create the adapter and plugin separately: $cache = StorageFactory::adapterFactory('apc', ['ttl' => 3600]); $plugin = StorageFactory::pluginFactory('exception_handler', [ 'throw_exceptions' => false, ]); $cache->addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apc(); $cache->getOptions()->setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin->getOptions()->setThrowExceptions(false); $cache->addPlugin($plugin); Basic Configuration Options The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \u201claminascache\u201d The \u201cnamespace\u201d in which cache items will live key_pattern null|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache The StorageInterface Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, & $success = null, & $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); } The AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); } The TotalSpaceCapableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); } The ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); } The ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); } The ClearExpiredInterface Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); } The FlushableInterface Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); } The IterableInterface Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); } The OptimizableInterface Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); } The TaggableInterface Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); } The Apc Adapter Laminas\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) supportedMetadata internal_key, atime, ctime, mtime, rtime, size, hits, ttl minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime value of apc.use_request_time from php.ini lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. The Dba Adapter Laminas\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata none minTtl 0 maxKeyLength 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. pathname string \"\" Pathname to the database file. mode string \"c\" The mode with which to open the database; please read dba_open for more information. handler string \"flatfile\" The name of the handler which shall be used for accessing the database. This adapter doesn't support automatic expiry Because this adapter doesn't support automatic expiry, it's very important to clean outdated items periodically! The Filesystem Adapter Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata mtime, filespec, atime, ctime minTtl 1 maxTtl 0 staticTtl false ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 251 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don\u2019t get \u2018fileatime\u2019 as \u2018atime\u2019 on metadata. no_ctime boolean true Don\u2019t get \u2018filectime\u2019 as \u2018ctime\u2019 on metadata. umask integer|false false Use umask to set file and directory permissions. suffix string dat Suffix for cache files tag_suffix string tag Suffix for tag files Note: the suffix and tag_suffix options will be escaped in order to be safe for glob operations. The Memcached Adapter Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter specific Options Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information The Redis Adapter Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the redis protocol using the PHP extension redis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter specific Options Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string Set the redis resource manager to use server See below. server can be described as any of the following: URI: /path/to/sock.sock Associative array: ['host' => <host>[, 'port' => <port>[, 'timeout' => <timeout>]]] List: [<host>[, <port>, [, <timeout>]]] The Memory Adapter The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource supportedMetadata mtime minTtl 1 maxTtl Value of PHP_INT_MAX staticTtl false ttlPrecision 0.05 useRequestTime false lockOnExpire 0 maxKeyLength 0 namespaceIsPrefix false Adapter specific Options Name Data Type Default Value Description memory_limit string|integer 50% of memory_limit INI value Limit of how much memory can PHP allocate to allow store items. Memory Limit The adapter has the following behavior with regards to the memory limit: If the consumed memory exceeds the limit provided, an OutOfSpaceException is thrown. A number less the or equal to zero disables the memory limit. When a value is provided for the memory limit, the value is measured in bytes. Shorthand notation may also be provided. Current process only! All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile. The MongoDB Adapter Laminas\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill . ext-mongodb If you are using the mongodb extension (vs the mongo extension), you will need to use the ExtMongoDb adapter instead. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Adapter specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoClient docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of options to pass to MongoClient (see the MongoClient docs ). driverOptions [] Associative array of driver options to pass to MongoClient (see the MongoClient docs ). The ExtMongoDB Adapter Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb ext-mongo If you are using the mongo extension (vs the mongodb extension), you will need to use the MongoDb adapter instead. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Adapter specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). The WinCache Adapter Laminas\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, ttl, hits, size minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime apc.use_request_time php.ini value. lockOnExpire 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. The XCache Adapter Laminas\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, size, refcount, hits, ctime, atime, hvalue minTtl 1 maxTtl xcache.var_maxttl php.ini value staticTtl true ttlPrecision 1 useRequestTime true lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. admin_auth boolean false Enable admin authentication by configuration options admin_user and admin_pass . This makes XCache administration functions accessible without the need of HTTP-Authentication if xcache.admin.enable_auth is enabled. admin_user string \"\" The username of xcache.admin.user . admin_pass string \"\" The password of xcache.admin.pass in plain text. The ZendServerDisk Adapter Laminas\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: The ZendServerShm Adapter Laminas\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: Examples Basic Usage use Laminas\\Cache\\StorageFactory; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem' ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false ], ], ]); $key = 'unique-cache-key'; $result = $cache->getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache->setItem($key, $result); } Get multiple Rows from a Database use Laminas\\Cache\\StorageFactory; // Instantiate the cache instance using a namespace for the same type of items $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key 'options' => [ 'namespace' => 'dbtable', ], ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false, ], // We store database rows on filesystem so we need to serialize them 'Serializer', ], ]); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache->getItems($ids); if (count($results) < count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo->query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache->setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Adapters"},{"location":"storage/adapter/#adapters","text":"Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass either the options instance or associative array to the Laminas\\Cache\\StorageFactory::factory method.","title":"Adapters"},{"location":"storage/adapter/#quick-start","text":"Caching adapters can either be created from the provided Laminas\\Cache\\StorageFactory , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\StorageFactory comes with a factory() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\StorageFactory; // Via factory: $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => ['ttl' => 3600], ], 'plugins' => [ 'exception_handler' => ['throw_exceptions' => false], ], ]); // Alternately, create the adapter and plugin separately: $cache = StorageFactory::adapterFactory('apc', ['ttl' => 3600]); $plugin = StorageFactory::pluginFactory('exception_handler', [ 'throw_exceptions' => false, ]); $cache->addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apc(); $cache->getOptions()->setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin->getOptions()->setThrowExceptions(false); $cache->addPlugin($plugin);","title":"Quick Start"},{"location":"storage/adapter/#basic-configuration-options","text":"The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \u201claminascache\u201d The \u201cnamespace\u201d in which cache items will live key_pattern null|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache","title":"Basic Configuration Options"},{"location":"storage/adapter/#the-storageinterface","text":"Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, & $success = null, & $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); }","title":"The StorageInterface"},{"location":"storage/adapter/#the-availablespacecapableinterface","text":"Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); }","title":"The AvailableSpaceCapableInterface"},{"location":"storage/adapter/#the-totalspacecapableinterface","text":"Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); }","title":"The TotalSpaceCapableInterface"},{"location":"storage/adapter/#the-clearbynamespaceinterface","text":"Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); }","title":"The ClearByNamespaceInterface"},{"location":"storage/adapter/#the-clearbyprefixinterface","text":"Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); }","title":"The ClearByPrefixInterface"},{"location":"storage/adapter/#the-clearexpiredinterface","text":"Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); }","title":"The ClearExpiredInterface"},{"location":"storage/adapter/#the-flushableinterface","text":"Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); }","title":"The FlushableInterface"},{"location":"storage/adapter/#the-iterableinterface","text":"Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); }","title":"The IterableInterface"},{"location":"storage/adapter/#the-optimizableinterface","text":"Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); }","title":"The OptimizableInterface"},{"location":"storage/adapter/#the-taggableinterface","text":"Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); }","title":"The TaggableInterface"},{"location":"storage/adapter/#the-apc-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Apc Adapter"},{"location":"storage/adapter/#the-dba-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Dba Adapter"},{"location":"storage/adapter/#the-filesystem-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Filesystem Adapter"},{"location":"storage/adapter/#the-memcached-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Memcached Adapter"},{"location":"storage/adapter/#the-redis-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the redis protocol using the PHP extension redis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Redis Adapter"},{"location":"storage/adapter/#the-memory-adapter","text":"The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Memory Adapter"},{"location":"storage/adapter/#the-mongodb-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill .","title":"The MongoDB Adapter"},{"location":"storage/adapter/#the-extmongodb-adapter","text":"Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb","title":"The ExtMongoDB Adapter"},{"location":"storage/adapter/#the-wincache-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The WinCache Adapter"},{"location":"storage/adapter/#the-xcache-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The XCache Adapter"},{"location":"storage/adapter/#the-zendserverdisk-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The ZendServerDisk Adapter"},{"location":"storage/adapter/#the-zendservershm-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The ZendServerShm Adapter"},{"location":"storage/adapter/#examples","text":"","title":"Examples"},{"location":"storage/capabilities/","text":"Storage Capabilities Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities . Available Methods namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get if expired items are readable * * @return bool * @deprecated This capability has been deprecated and will be removed in the future. * Please use getStaticTtl() instead */ public function getExpiredRead(); /** * Set if expired items are readable * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface * @deprecated This capability has been deprecated and will be removed in the future. * Please use setStaticTtl() instead */ public function setExpiredRead(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * >0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this->getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this->setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); } Examples Get Storage Capabilities and do specific Stuff based on them use Laminas\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem'); $supportedDatatypes = $cache->getCapabilities()->getSupportedDatatypes(); // now you can run specific stuff in base of supported feature if ($supportedDatatypes['object']) { $cache->set($key, $object); } else { $cache->set($key, serialize($object)); } Listen to the change Event use Laminas\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem', [ 'no_atime' => false, ]); // Catching capability changes $cache->getEventManager()->attach('capability', function($event) { echo count($event->getParams()) . ' capabilities changed'; }); // change option which changes capabilities $cache->getOptions()->setNoATime(true);","title":"Capabilities"},{"location":"storage/capabilities/#storage-capabilities","text":"Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities .","title":"Storage Capabilities"},{"location":"storage/capabilities/#available-methods","text":"namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get if expired items are readable * * @return bool * @deprecated This capability has been deprecated and will be removed in the future. * Please use getStaticTtl() instead */ public function getExpiredRead(); /** * Set if expired items are readable * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface * @deprecated This capability has been deprecated and will be removed in the future. * Please use setStaticTtl() instead */ public function setExpiredRead(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * >0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this->getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this->setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); }","title":"Available Methods"},{"location":"storage/capabilities/#examples","text":"","title":"Examples"},{"location":"storage/plugin/","text":"Plugins Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent ) Quick Start Storage plugins can either be created from Laminas\\Cache\\StorageFactory::pluginFactory() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\StorageFactory::factory() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\StorageFactory; // All at once: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => ['serializer'], ]); // Alternately, via discrete factory methods: $cache = StorageFactory::adapterFactory('filesystem'); $plugin = StorageFactory::pluginFactory('serializer'); $cache->addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache->addPlugin($plugin); The ClearExpiredByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() . Plugin specific Options Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor. Adapter must implement ClearExpiredInterface The storage adapter must implement Laminas\\Cache\\Storage\\ClearExpiredInterface to work with this plugin. The ExceptionHandler Plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions. Plugin specific Options Name Data Type Default Value Description exception_callback callable|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions. The IgnoreUserAbort Plugin Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first. Plugin specific Options Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort. The OptimizeByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache. Plugin specific Options Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor. Adapter must implement OptimizableInterface The storage adapter must implement Laminas\\Cache\\Storage\\OptimizableInterface to work with this plugin. The Serializer Plugin Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter. Plugin specific Options Name Data Type Default Value Description serializer null|string|Laminas\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Laminas\\Serializer\\AdapterPluginManager , with the provided serializer_options . Available Methods The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); } Examples Basic Plugin Implementation use Laminas\\Cache\\Storage\\Event; use Laminas\\Cache\\Storage\\Plugin\\AbstractPlugin; use Laminas\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events) { $this->handles[] = $events->attach('getItem.pre', array($this, 'onGetItemPre')); $this->handles[] = $events->attach('getItem.post', array($this, 'onGetItemPost')); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events) { foreach ($this->handles as $handle) { $events->detach($handle); } $this->handles = []; } public function onGetItemPre(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache->addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache->getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Plugins"},{"location":"storage/plugin/#plugins","text":"Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent )","title":"Plugins"},{"location":"storage/plugin/#quick-start","text":"Storage plugins can either be created from Laminas\\Cache\\StorageFactory::pluginFactory() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\StorageFactory::factory() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\StorageFactory; // All at once: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => ['serializer'], ]); // Alternately, via discrete factory methods: $cache = StorageFactory::adapterFactory('filesystem'); $plugin = StorageFactory::pluginFactory('serializer'); $cache->addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache->addPlugin($plugin);","title":"Quick Start"},{"location":"storage/plugin/#the-clearexpiredbyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() .","title":"The ClearExpiredByFactor Plugin"},{"location":"storage/plugin/#the-exceptionhandler-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions.","title":"The ExceptionHandler Plugin"},{"location":"storage/plugin/#the-ignoreuserabort-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first.","title":"The IgnoreUserAbort Plugin"},{"location":"storage/plugin/#the-optimizebyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache.","title":"The OptimizeByFactor Plugin"},{"location":"storage/plugin/#the-serializer-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter.","title":"The Serializer Plugin"},{"location":"storage/plugin/#available-methods","text":"The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); }","title":"Available Methods"},{"location":"storage/plugin/#examples","text":"","title":"Examples"}]}